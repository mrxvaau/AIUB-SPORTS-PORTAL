const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Store active tunnel processes and URLs
let tunnelState = {
    active: false,
    frontendProcess: null,
    backendProcess: null,
    frontendUrl: null,
    backendUrl: null,
    frontendPid: null,
    backendPid: null
};

const TUNNEL_STATE_FILE = path.join(__dirname, '../tunnel-state.json');
const FRONTEND_CONFIG_FILE = path.join(__dirname, '../../frontend/js/tunnel-config.js');

/**
 * Parse localtunnel output to extract tunnel URL
 */
function parseTunnelUrl(data) {
    const output = data.toString();
    const urlMatch = output.match(/https:\/\/[a-z0-9-]+\.loca\.lt/);
    return urlMatch ? urlMatch[0] : null;
}

/**
 * Write tunnel configuration to frontend directory
 */
function writeFrontendConfig(backendUrl) {
    const content = `// Auto-generated by tunnelController.js
const TUNNEL_CONFIG = {
    backendUrl: ${backendUrl ? `'${backendUrl}'` : 'null'},
    updatedAt: '${new Date().toISOString()}'
};
`;
    try {
        // Ensure directory exists
        const dir = path.dirname(FRONTEND_CONFIG_FILE);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(FRONTEND_CONFIG_FILE, content);
        console.log('Updated frontend tunnel config:', backendUrl || 'CLEARED');
    } catch (error) {
        console.error('Error writing frontend config:', error);
    }
}

/**
 * Save tunnel state to file for persistence
 */
function saveTunnelState() {
    try {
        fs.writeFileSync(TUNNEL_STATE_FILE, JSON.stringify({
            active: tunnelState.active,
            frontendUrl: tunnelState.frontendUrl,
            backendUrl: tunnelState.backendUrl,
            timestamp: new Date().toISOString()
        }));
    } catch (error) {
        console.error('Error saving tunnel state:', error);
    }
}

/**
 * Load tunnel state from file
 */
function loadTunnelState() {
    try {
        if (fs.existsSync(TUNNEL_STATE_FILE)) {
            const state = JSON.parse(fs.readFileSync(TUNNEL_STATE_FILE, 'utf8'));
            // Don't auto-restore processes, just show last known state
            return state;
        }
    } catch (error) {
        console.error('Error loading tunnel state:', error);
    }
    return null;
}

/**
 * Start tunneling for both frontend and backend
 */
const startTunnels = async (req, res) => {
    try {
        // Check if tunnels are already running
        if (tunnelState.active) {
            return res.status(400).json({
                success: false,
                message: 'Tunnels are already active',
                frontendUrl: tunnelState.frontendUrl,
                backendUrl: tunnelState.backendUrl
            });
        }

        console.log('ðŸŒ Starting port forwarding tunnels...');

        // Start frontend tunnel (port 3001)
        const frontendTunnel = spawn('npx', ['localtunnel', '--port', '3001'], {
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        // Start backend tunnel (port 3000)
        const backendTunnel = spawn('npx', ['localtunnel', '--port', '3000'], {
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        let frontendUrlResolved = false;
        let backendUrlResolved = false;

        // Create promises to wait for both tunnel URLs
        const frontendUrlPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Frontend tunnel timeout'));
            }, 30000); // 30 second timeout

            frontendTunnel.stdout.on('data', (data) => {
                console.log('Frontend tunnel output:', data.toString());
                const url = parseTunnelUrl(data);
                if (url && !frontendUrlResolved) {
                    frontendUrlResolved = true;
                    clearTimeout(timeout);
                    tunnelState.frontendUrl = url;
                    tunnelState.frontendProcess = frontendTunnel;
                    tunnelState.frontendPid = frontendTunnel.pid;
                    resolve(url);
                }
            });

            frontendTunnel.stderr.on('data', (data) => {
                console.error('Frontend tunnel error:', data.toString());
            });

            frontendTunnel.on('error', (error) => {
                clearTimeout(timeout);
                reject(error);
            });
        });

        const backendUrlPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Backend tunnel timeout'));
            }, 30000); // 30 second timeout

            backendTunnel.stdout.on('data', (data) => {
                console.log('Backend tunnel output:', data.toString());
                const url = parseTunnelUrl(data);
                if (url && !backendUrlResolved) {
                    backendUrlResolved = true;
                    clearTimeout(timeout);
                    tunnelState.backendUrl = url;
                    tunnelState.backendProcess = backendTunnel;
                    tunnelState.backendPid = backendTunnel.pid;
                    resolve(url);
                }
            });

            backendTunnel.stderr.on('data', (data) => {
                console.error('Backend tunnel error:', data.toString());
            });

            backendTunnel.on('error', (error) => {
                clearTimeout(timeout);
                reject(error);
            });
        });

        // Wait for both tunnels to be ready
        try {
            await Promise.all([frontendUrlPromise, backendUrlPromise]);

            tunnelState.active = true;

            // Update CORS to allow tunnel URL
            process.env.TUNNEL_FRONTEND_URL = tunnelState.frontendUrl;

            saveTunnelState();
            writeFrontendConfig(tunnelState.backendUrl);

            console.log('âœ… Tunnels started successfully!');
            console.log('   Frontend:', tunnelState.frontendUrl);
            console.log('   Backend:', tunnelState.backendUrl);

            res.json({
                success: true,
                message: 'Tunnels started successfully',
                frontendUrl: tunnelState.frontendUrl,
                backendUrl: tunnelState.backendUrl
            });

            // Handle process exits
            frontendTunnel.on('exit', (code) => {
                console.log(`Frontend tunnel exited with code ${code}`);
                if (tunnelState.active) {
                    tunnelState.active = false;
                    tunnelState.frontendProcess = null;
                    saveTunnelState();
                }
            });

            backendTunnel.on('exit', (code) => {
                console.log(`Backend tunnel exited with code ${code}`);
                if (tunnelState.active) {
                    tunnelState.active = false;
                    tunnelState.backendProcess = null;
                    saveTunnelState();
                    writeFrontendConfig(null);
                }
            });

        } catch (error) {
            // Clean up if one tunnel fails
            if (frontendTunnel) frontendTunnel.kill();
            if (backendTunnel) backendTunnel.kill();
            throw error;
        }

    } catch (error) {
        console.error('âŒ Error starting tunnels:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to start tunnels: ' + error.message
        });
    }
};

/**
 * Stop all active tunnels
 */
const stopTunnels = async (req, res) => {
    try {
        console.log('ðŸ›‘ Stopping port forwarding tunnels...');

        let stopped = false;

        if (tunnelState.frontendProcess) {
            tunnelState.frontendProcess.kill();
            tunnelState.frontendProcess = null;
            stopped = true;
        }

        if (tunnelState.backendProcess) {
            tunnelState.backendProcess.kill();
            tunnelState.backendProcess = null;
            stopped = true;
        }

        tunnelState.active = false;
        tunnelState.frontendUrl = null;
        tunnelState.backendUrl = null;
        tunnelState.frontendPid = null;
        tunnelState.backendPid = null;

        // Clear environment variable
        delete process.env.TUNNEL_FRONTEND_URL;

        saveTunnelState();
        writeFrontendConfig(null);

        console.log('âœ… Tunnels stopped successfully');

        res.json({
            success: true,
            message: stopped ? 'Tunnels stopped successfully' : 'No active tunnels to stop'
        });

    } catch (error) {
        console.error('âŒ Error stopping tunnels:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to stop tunnels: ' + error.message
        });
    }
};

/**
 * Get current tunnel status
 */
const getTunnelStatus = async (req, res) => {
    try {
        // Check if processes are still running
        let processesRunning = false;

        if (tunnelState.frontendProcess && tunnelState.backendProcess) {
            // Both processes exist, assume active
            processesRunning = true;
        }

        res.json({
            success: true,
            active: tunnelState.active && processesRunning,
            frontendUrl: tunnelState.frontendUrl,
            backendUrl: tunnelState.backendUrl,
            frontendPid: tunnelState.frontendPid,
            backendPid: tunnelState.backendPid
        });

    } catch (error) {
        console.error('âŒ Error getting tunnel status:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get tunnel status: ' + error.message
        });
    }
};

/**
 * Clean up tunnels on server shutdown
 */
function cleanupTunnels() {
    console.log('ðŸ§¹ Cleaning up tunnels on shutdown...');

    if (tunnelState.frontendProcess) {
        tunnelState.frontendProcess.kill();
    }

    if (tunnelState.backendProcess) {
        tunnelState.backendProcess.kill();
    }

    // Attempt to clear config
    try {
        writeFrontendConfig(null);
    } catch (e) {
        // Ignore errors during cleanup
    }
}

// Register cleanup handlers
process.on('SIGINT', () => {
    cleanupTunnels();
    process.exit();
});

process.on('SIGTERM', () => {
    cleanupTunnels();
    process.exit();
});

module.exports = {
    startTunnels,
    stopTunnels,
    getTunnelStatus,
    cleanupTunnels
};
