const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration constants
const TUNNEL_STARTUP_TIMEOUT_MS = 30000; // 30 seconds
const FRONTEND_PORT = process.env.FRONTEND_PORT || 3001;
const BACKEND_PORT = process.env.PORT || 3000;

// Store active tunnel processes and URLs
let tunnelState = {
    active: false,
    frontendProcess: null,
    backendProcess: null,
    frontendUrl: null,
    backendUrl: null,
    frontendPid: null,
    backendPid: null
};

// Operation lock to prevent race conditions
let tunnelOperationInProgress = false;

const TUNNEL_STATE_FILE = path.join(__dirname, '../tunnel-state.json');
const FRONTEND_CONFIG_FILE = path.join(
    process.env.FRONTEND_DIR || path.join(__dirname, '../../frontend'),
    'js/tunnel-config.js'
);

/**
 * Parse localtunnel output to extract tunnel URL
 */
function parseTunnelUrl(data) {
    const output = data.toString();
    const urlMatch = output.match(/https:\/\/[a-z0-9-]+\.loca\.lt/);
    return urlMatch ? urlMatch[0] : null;
}

/**
 * Write tunnel configuration to frontend directory
 */
function writeFrontendConfig(backendUrl) {
    // Validate URL format if provided
    if (backendUrl && !backendUrl.match(/^https:\/\/[a-z0-9-]+\.loca\.lt$/)) {
        console.error('‚ùå Invalid tunnel URL format:', backendUrl);
        return;
    }

    const content = `// Auto-generated by tunnelController.js
const TUNNEL_CONFIG = {
    backendUrl: ${backendUrl ? `'${backendUrl}'` : 'null'},
    updatedAt: '${new Date().toISOString()}'
};
`;
    try {
        // Ensure directory exists
        const dir = path.dirname(FRONTEND_CONFIG_FILE);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(FRONTEND_CONFIG_FILE, content);
        console.log('‚úÖ Updated frontend tunnel config:', backendUrl || 'CLEARED');
    } catch (error) {
        console.error('‚ùå Error writing frontend config:', error);
    }
}

/**
 * Save tunnel state to file for persistence
 */
function saveTunnelState() {
    try {
        fs.writeFileSync(TUNNEL_STATE_FILE, JSON.stringify({
            active: tunnelState.active,
            frontendUrl: tunnelState.frontendUrl,
            backendUrl: tunnelState.backendUrl,
            timestamp: new Date().toISOString()
        }));
    } catch (error) {
        console.error('Error saving tunnel state:', error);
    }
}

/**
 * Load tunnel state from file
 */
function loadTunnelState() {
    try {
        if (fs.existsSync(TUNNEL_STATE_FILE)) {
            const state = JSON.parse(fs.readFileSync(TUNNEL_STATE_FILE, 'utf8'));
            // Don't auto-restore processes, just show last known state
            return state;
        }
    } catch (error) {
        console.error('Error loading tunnel state:', error);
    }
    return null;
}

/**
 * Start tunneling for both frontend and backend
 */
const startTunnels = async (req, res) => {
    // Check if operation is in progress
    if (tunnelOperationInProgress) {
        return res.status(409).json({
            success: false,
            message: 'Tunnel operation already in progress, please wait'
        });
    }

    try {
        tunnelOperationInProgress = true;

        // Check if tunnels are already running
        if (tunnelState.active) {
            return res.status(400).json({
                success: false,
                message: 'Tunnels are already active',
                frontendUrl: tunnelState.frontendUrl,
                backendUrl: tunnelState.backendUrl
            });
        }

        console.log('üåê Starting port forwarding tunnels...');
        console.log(`   Frontend Port: ${FRONTEND_PORT}`);
        console.log(`   Backend Port: ${BACKEND_PORT}`);

        // Start frontend tunnel
        const frontendTunnel = spawn('npx', ['localtunnel', '--port', FRONTEND_PORT.toString()], {
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        // Start backend tunnel
        const backendTunnel = spawn('npx', ['localtunnel', '--port', BACKEND_PORT.toString()], {
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
        });

        let frontendUrlResolved = false;
        let backendUrlResolved = false;
        let frontendStderr = '';
        let backendStderr = '';

        // Create promises to wait for both tunnel URLs
        const frontendUrlPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error(`Frontend tunnel timeout after ${TUNNEL_STARTUP_TIMEOUT_MS}ms. Error: ${frontendStderr}`));
            }, TUNNEL_STARTUP_TIMEOUT_MS);

            frontendTunnel.stdout.on('data', (data) => {
                console.log('Frontend tunnel output:', data.toString());
                const url = parseTunnelUrl(data);
                if (url && !frontendUrlResolved) {
                    frontendUrlResolved = true;
                    clearTimeout(timeout);
                    tunnelState.frontendUrl = url;
                    tunnelState.frontendProcess = frontendTunnel;
                    tunnelState.frontendPid = frontendTunnel.pid;
                    resolve(url);
                }
            });

            frontendTunnel.stderr.on('data', (data) => {
                const errMsg = data.toString();
                frontendStderr += errMsg;
                console.error('Frontend tunnel error:', errMsg);
            });

            frontendTunnel.on('error', (error) => {
                clearTimeout(timeout);
                reject(new Error(`Frontend tunnel process error: ${error.message}`));
            });
        });

        const backendUrlPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error(`Backend tunnel timeout after ${TUNNEL_STARTUP_TIMEOUT_MS}ms. Error: ${backendStderr}`));
            }, TUNNEL_STARTUP_TIMEOUT_MS);

            backendTunnel.stdout.on('data', (data) => {
                console.log('Backend tunnel output:', data.toString());
                const url = parseTunnelUrl(data);
                if (url && !backendUrlResolved) {
                    backendUrlResolved = true;
                    clearTimeout(timeout);
                    tunnelState.backendUrl = url;
                    tunnelState.backendProcess = backendTunnel;
                    tunnelState.backendPid = backendTunnel.pid;
                    resolve(url);
                }
            });

            backendTunnel.stderr.on('data', (data) => {
                const errMsg = data.toString();
                backendStderr += errMsg;
                console.error('Backend tunnel error:', errMsg);
            });

            backendTunnel.on('error', (error) => {
                clearTimeout(timeout);
                reject(new Error(`Backend tunnel process error: ${error.message}`));
            });
        });

        // Wait for both tunnels to be ready
        try {
            await Promise.all([frontendUrlPromise, backendUrlPromise]);

            tunnelState.active = true;

            // Update CORS to allow tunnel URL
            process.env.TUNNEL_FRONTEND_URL = tunnelState.frontendUrl;

            saveTunnelState();
            writeFrontendConfig(tunnelState.backendUrl);

            console.log('‚úÖ Tunnels started successfully!');
            console.log('   Frontend:', tunnelState.frontendUrl);
            console.log('   Backend:', tunnelState.backendUrl);
            console.log('   Frontend PID:', tunnelState.frontendPid);
            console.log('   Backend PID:', tunnelState.backendPid);

            res.json({
                success: true,
                message: 'Tunnels started successfully',
                frontendUrl: tunnelState.frontendUrl,
                backendUrl: tunnelState.backendUrl
            });

            // Handle process exits
            frontendTunnel.on('exit', (code) => {
                console.log(`‚ö†Ô∏è Frontend tunnel exited with code ${code}`);
                if (tunnelState.active) {
                    tunnelState.active = false;
                    tunnelState.frontendProcess = null;
                    saveTunnelState();
                }
            });

            backendTunnel.on('exit', (code) => {
                console.log(`‚ö†Ô∏è Backend tunnel exited with code ${code}`);
                if (tunnelState.active) {
                    tunnelState.active = false;
                    tunnelState.backendProcess = null;
                    saveTunnelState();
                    writeFrontendConfig(null);
                }
            });

        } catch (error) {
            // Clean up if one tunnel fails
            if (frontendTunnel) frontendTunnel.kill();
            if (backendTunnel) backendTunnel.kill();
            throw error;
        }

    } catch (error) {
        console.error('‚ùå Error starting tunnels:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to start tunnels: ' + error.message,
            details: error.message
        });
    } finally {
        tunnelOperationInProgress = false;
    }
};

/**
 * Stop all active tunnels
 */
const stopTunnels = async (req, res) => {
    try {
        console.log('üõë Stopping port forwarding tunnels...');

        let stopped = false;

        if (tunnelState.frontendProcess) {
            tunnelState.frontendProcess.kill();
            tunnelState.frontendProcess = null;
            stopped = true;
        }

        if (tunnelState.backendProcess) {
            tunnelState.backendProcess.kill();
            tunnelState.backendProcess = null;
            stopped = true;
        }

        tunnelState.active = false;
        tunnelState.frontendUrl = null;
        tunnelState.backendUrl = null;
        tunnelState.frontendPid = null;
        tunnelState.backendPid = null;

        // Clear environment variable
        delete process.env.TUNNEL_FRONTEND_URL;

        saveTunnelState();
        writeFrontendConfig(null);

        console.log('‚úÖ Tunnels stopped successfully');

        res.json({
            success: true,
            message: stopped ? 'Tunnels stopped successfully' : 'No active tunnels to stop'
        });

    } catch (error) {
        console.error('‚ùå Error stopping tunnels:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to stop tunnels: ' + error.message
        });
    }
};

/**
 * Get current tunnel status
 */
const getTunnelStatus = async (req, res) => {
    try {
        let processesRunning = false;

        if (tunnelState.frontendPid && tunnelState.backendPid) {
            // Verify processes are actually running (not just that state exists)
            try {
                // Signal 0 checks if process exists without killing it
                process.kill(tunnelState.frontendPid, 0);
                process.kill(tunnelState.backendPid, 0);
                processesRunning = true;
            } catch (e) {
                // One or both processes don't exist, clear state
                console.warn('‚ö†Ô∏è Tunnel processes not running, clearing state');
                tunnelState.active = false;
                tunnelState.frontendProcess = null;
                tunnelState.backendProcess = null;
                tunnelState.frontendPid = null;
                tunnelState.backendPid = null;
                saveTunnelState();
                writeFrontendConfig(null);
            }
        }

        res.json({
            success: true,
            active: tunnelState.active && processesRunning,
            frontendUrl: processesRunning ? tunnelState.frontendUrl : null,
            backendUrl: processesRunning ? tunnelState.backendUrl : null,
            frontendPid: processesRunning ? tunnelState.frontendPid : null,
            backendPid: processesRunning ? tunnelState.backendPid : null
        });

    } catch (error) {
        console.error('‚ùå Error getting tunnel status:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to get tunnel status: ' + error.message
        });
    }
};

/**
 * Clean up tunnels on server shutdown
 */
function cleanupTunnels() {
    console.log('üßπ Cleaning up tunnels on shutdown...');

    if (process.platform === 'win32') {
        // Force kill by PID on Windows
        if (tunnelState.frontendPid) {
            try {
                process.kill(tunnelState.frontendPid, 'SIGKILL');
                console.log('‚úÖ Killed frontend tunnel process (PID:', tunnelState.frontendPid, ')');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not kill frontend tunnel:', e.message);
            }
        }
        if (tunnelState.backendPid) {
            try {
                process.kill(tunnelState.backendPid, 'SIGKILL');
                console.log('‚úÖ Killed backend tunnel process (PID:', tunnelState.backendPid, ')');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not kill backend tunnel:', e.message);
            }
        }
    } else {
        // Unix systems - use process objects
        if (tunnelState.frontendProcess) {
            try {
                tunnelState.frontendProcess.kill();
                console.log('‚úÖ Killed frontend tunnel process');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not kill frontend tunnel:', e.message);
            }
        }
        if (tunnelState.backendProcess) {
            try {
                tunnelState.backendProcess.kill();
                console.log('‚úÖ Killed backend tunnel process');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not kill backend tunnel:', e.message);
            }
        }
    }

    // Clear state
    tunnelState.active = false;
    tunnelState.frontendProcess = null;
    tunnelState.backendProcess = null;
    tunnelState.frontendPid = null;
    tunnelState.backendPid = null;

    // Attempt to clear config
    try {
        writeFrontendConfig(null);
        saveTunnelState();
    } catch (e) {
        // Ignore errors during cleanup
        console.warn('‚ö†Ô∏è Error during config cleanup:', e.message);
    }
}

// Register cleanup handlers
process.on('SIGINT', () => {
    console.log('\n‚ö†Ô∏è Received SIGINT, cleaning up...');
    cleanupTunnels();
    process.exit();
});

process.on('SIGTERM', () => {
    console.log('\n‚ö†Ô∏è Received SIGTERM, cleaning up...');
    cleanupTunnels();
    process.exit();
});

// Windows-specific cleanup handler
if (process.platform === 'win32') {
    process.on('beforeExit', () => {
        console.log('\n‚ö†Ô∏è Process exiting, cleaning up tunnels...');
        cleanupTunnels();
    });

    // Handle Ctrl+C on Windows properly
    if (process.stdin.isTTY) {
        require('readline')
            .createInterface({ input: process.stdin, output: process.stdout })
            .on('SIGINT', () => {
                console.log('\n‚ö†Ô∏è Received Ctrl+C, cleaning up...');
                process.emit('SIGINT');
            });
    }
}

module.exports = {
    startTunnels,
    stopTunnels,
    getTunnelStatus,
    cleanupTunnels
};
